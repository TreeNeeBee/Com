/**
 * @file        SlotAllocator.hpp
 * @author      Generated by LightAP Architecture Optimizer
 * @brief       Service Slot Allocator (Static + Dynamic Mapping)
 * @date        2025-11-19
 * @details     服务 ID → 槽位索引映射器
 *              - 静态分配: 从 YAML 配置加载固定映射
 *              - 动态分配: Hash + Linear Probing
 *              - 冲突解决: 开放寻址法
 * @copyright   Copyright (c) 2025
 * @version     1.0
 */
#ifndef LAP_COM_SLOT_ALLOCATOR_HPP
#define LAP_COM_SLOT_ALLOCATOR_HPP

#include "ComTypes.hpp"
#include <core/CResult.hpp>

#include <string>
#include <unordered_map>
#include <cstdint>
#include <optional>

namespace lap
{
namespace com
{
namespace registry
{
    // ========================================================================
    // Slot Mapping Entry
    // ========================================================================
    
    /**
     * @brief 槽位映射条目
     */
    struct SlotMappingEntry {
        std::string service_interface_name;  ///< 服务接口名称
        InstanceIdentifier instance_id;      ///< 实例标识符
        uint32_t slot_index;                 ///< 槽位索引
        uint32_t safety_level;               ///< 安全等级 (0=QM, 2=ASIL-D)
        std::string description;             ///< 描述信息
    };
    
    // ========================================================================
    // Slot Allocator Configuration
    // ========================================================================
    
    /**
     * @brief 槽位分配器配置
     */
    struct SlotAllocatorConfig {
        // Static allocation range
        uint32_t static_slot_start = 0;
        uint32_t static_slot_end = 199;
        
        // Dynamic allocation range
        uint32_t dynamic_slot_start = 200;
        uint32_t dynamic_slot_end = 1023;
        
        // Configuration file
        std::string slot_mapping_file = "/etc/lap/com/slot_mapping.yaml";
        
        // Hash algorithm
        enum class HashAlgorithm {
            CRC32,        ///< CRC32 哈希
            FNV1A,        ///< FNV-1a 哈希
            MURMUR3       ///< MurmurHash3
        } hash_algorithm = HashAlgorithm::FNV1A;
        
        // Collision resolution
        enum class CollisionResolution {
            LINEAR_PROBING,   ///< 线性探测
            QUADRATIC         ///< 二次探测
        } collision_resolution = CollisionResolution::LINEAR_PROBING;
        
        // Maximum probing steps
        uint32_t max_probing_steps = 10;
    };
    
    // ========================================================================
    // Slot Allocator (Service ID → Slot Index Mapping)
    // ========================================================================
    
    /**
     * @brief 槽位分配器 - 管理服务到槽位的映射
     * @note 线程安全
     */
    class SlotAllocator {
    public:
        /**
         * @brief 构造函数
         * @param config 配置选项
         */
        explicit SlotAllocator(const SlotAllocatorConfig& config = SlotAllocatorConfig{});
        
        /**
         * @brief 析构函数
         */
        ~SlotAllocator() = default;
        
        /**
         * @brief 初始化，加载静态映射配置
         * @return Result indicating success
         */
        lap::core::Result<void> Initialize();
        
        /**
         * @brief 分配槽位索引 (静态优先，动态回退)
         * @param service_interface_name 服务接口名称
         * @param instance_id 实例标识符
         * @return Result containing allocated slot index
         */
        lap::core::Result<uint32_t> AllocateSlot(
            const std::string& service_interface_name,
            const InstanceIdentifier& instance_id);
        
        /**
         * @brief 获取已分配的槽位索引
         * @param service_interface_name 服务接口名称
         * @param instance_id 实例标识符
         * @return Optional slot index (nullopt if not allocated)
         */
        std::optional<uint32_t> GetSlotIndex(
            const std::string& service_interface_name,
            const InstanceIdentifier& instance_id) const;
        
        /**
         * @brief 释放槽位索引
         * @param service_interface_name 服务接口名称
         * @param instance_id 实例标识符
         * @return Result indicating success
         */
        lap::core::Result<void> DeallocateSlot(
            const std::string& service_interface_name,
            const InstanceIdentifier& instance_id);
        
        /**
         * @brief 检查槽位是否已分配
         * @param slot_index 槽位索引
         * @return true if allocated
         */
        bool IsSlotAllocated(uint32_t slot_index) const;
        
        /**
         * @brief 从 YAML 加载静态映射
         * @param yaml_path YAML 配置文件路径
         * @return Result containing loaded entries count
         */
        lap::core::Result<uint32_t> LoadStaticMappings(const std::string& yaml_path);
        
        /**
         * @brief 打印槽位分配状态
         */
        void DumpAllocations() const;
        
    private:
        // ====================================================================
        // Hash Functions
        // ====================================================================
        
        /**
         * @brief 计算服务 ID 哈希值
         * @param service_interface_name 服务接口名称
         * @param instance_id 实例标识符
         * @return Hash value
         */
        uint64_t ComputeServiceHash(
            const std::string& service_interface_name,
            const InstanceIdentifier& instance_id) const;
        
        /**
         * @brief FNV-1a 哈希算法
         * @param data 数据指针
         * @param len 数据长度
         * @return Hash value
         */
        static uint64_t FNV1aHash(const void* data, size_t len);
        
        /**
         * @brief CRC32 哈希算法
         * @param data 数据指针
         * @param len 数据长度
         * @return Hash value
         */
        static uint32_t CRC32Hash(const void* data, size_t len);
        
        // ====================================================================
        // Collision Resolution
        // ====================================================================
        
        /**
         * @brief 线性探测查找空闲槽位
         * @param initial_slot 初始槽位索引
         * @return Optional free slot index
         */
        std::optional<uint32_t> LinearProbing(uint32_t initial_slot);
        
        /**
         * @brief 二次探测查找空闲槽位
         * @param initial_slot 初始槽位索引
         * @return Optional free slot index
         */
        std::optional<uint32_t> QuadraticProbing(uint32_t initial_slot);
        
        // ====================================================================
        // Private Members
        // ====================================================================
        
        SlotAllocatorConfig config_;
        
        // Static mappings (loaded from YAML)
        std::unordered_map<std::string, uint32_t> static_mappings_;  ///< Key: "ServiceName/InstanceID"
        
        // Dynamic allocations (runtime allocated)
        std::unordered_map<std::string, uint32_t> dynamic_allocations_;
        
        // Reverse mapping (slot → service)
        std::unordered_map<uint32_t, std::string> reverse_mappings_;
        
        // Thread safety
        mutable std::mutex mutex_;
    };

} // namespace registry
} // namespace com
} // namespace lap

#endif // LAP_COM_SLOT_ALLOCATOR_HPP
